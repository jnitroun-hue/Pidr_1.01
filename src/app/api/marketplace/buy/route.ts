import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

function getSupabaseClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!supabaseUrl || !supabaseServiceKey) {
    throw new Error('Supabase credentials not configured');
  }
  return createClient(supabaseUrl, supabaseServiceKey);
}

/**
 * POST /api/marketplace/buy
 * 
 * –ö—É–ø–∏—Ç—å NFT –∫–∞—Ä—Ç—É —Å –º–∞—Ä–∫–µ—Ç–ø–ª–µ–π—Å–∞
 * 
 * Body:
 * {
 *   listing_id: number,
 *   payment_method: 'coins' | 'crypto'
 * }
 * 
 * Headers:
 * - x-telegram-id: telegram user ID
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = getSupabaseClient();
    
    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const telegramIdHeader = request.headers.get('x-telegram-id');
    
    if (!telegramIdHeader) {
      return NextResponse.json(
        { success: false, error: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }
    
    const buyerId = parseInt(telegramIdHeader, 10);
    
    if (isNaN(buyerId)) {
      return NextResponse.json(
        { success: false, error: '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç telegram_id' },
        { status: 400 }
      );
    }
    
    const body = await request.json();
    const { listing_id, payment_method } = body;
    
    console.log('üí∞ [Marketplace Buy] –ü–æ–∫—É–ø–∫–∞:', { buyerId, listing_id, payment_method });
    
    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (!listing_id || !payment_method) {
      return NextResponse.json(
        { success: false, error: 'listing_id –∏ payment_method –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' },
        { status: 400 }
      );
    }
    
    // –ü–æ–ª—É—á–∞–µ–º –ª–æ—Ç
    const { data: listing, error: listingError } = await supabase
      .from('_pidr_nft_marketplace')
      .select(`
        *,
        nft_card:_pidr_nft_cards(*)
      `)
      .eq('id', listing_id)
      .single();
    
    if (listingError || !listing) {
      console.error('‚ùå [Marketplace Buy] –õ–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω:', listingError);
      return NextResponse.json(
        { success: false, error: '–õ–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' },
        { status: 404 }
      );
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∏
    if (listing.status !== 'active') {
      return NextResponse.json(
        { success: false, error: '–õ–æ—Ç –Ω–µ–∞–∫—Ç–∏–≤–µ–Ω' },
        { status: 400 }
      );
    }
    
    if (listing.seller_user_id === buyerId) {
      return NextResponse.json(
        { success: false, error: '–ù–µ–ª—å–∑—è –∫—É–ø–∏—Ç—å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—É—é –∫–∞—Ä—Ç—É' },
        { status: 400 }
      );
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –æ–ø–ª–∞—Ç—ã
    const price = payment_method === 'coins' ? listing.price_coins : listing.price_crypto;
    
    if (!price) {
      return NextResponse.json(
        { success: false, error: `–≠—Ç–æ—Ç –ª–æ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è –æ–ø–ª–∞—Ç—ã ${payment_method}` },
        { status: 400 }
      );
    }
    
    // –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å –ø–æ–∫—É–ø–∞—Ç–µ–ª—è
    const { data: buyer, error: buyerError } = await supabase
      .from('_pidr_users')
      .select('telegram_id, coins')
      .eq('telegram_id', buyerId)
      .single();
    
    if (buyerError || !buyer) {
      console.error('‚ùå [Marketplace Buy] –ü–æ–∫—É–ø–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω:', buyerError);
      return NextResponse.json(
        { success: false, error: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' },
        { status: 404 }
      );
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å (—Ç–æ–ª—å–∫–æ –¥–ª—è coins)
    if (payment_method === 'coins') {
      if (buyer.coins < price) {
        return NextResponse.json(
          { success: false, error: `–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç. –¢—Ä–µ–±—É–µ—Ç—Å—è: ${price}, –µ—Å—Ç—å: ${buyer.coins}` },
          { status: 400 }
        );
      }
    }
    
    // –ù–∞—á–∏–Ω–∞–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
    // 1. –°–ø–∏—Å—ã–≤–∞–µ–º –º–æ–Ω–µ—Ç—ã —É –ø–æ–∫—É–ø–∞—Ç–µ–ª—è
    if (payment_method === 'coins') {
      const { error: deductError } = await supabase
        .from('_pidr_users')
        .update({ coins: buyer.coins - price })
        .eq('telegram_id', buyerId);
      
      if (deductError) {
        console.error('‚ùå [Marketplace Buy] –û—à–∏–±–∫–∞ —Å–ø–∏—Å–∞–Ω–∏—è –º–æ–Ω–µ—Ç:', deductError);
        return NextResponse.json(
          { success: false, error: '–û—à–∏–±–∫–∞ —Å–ø–∏—Å–∞–Ω–∏—è –º–æ–Ω–µ—Ç' },
          { status: 500 }
        );
      }
    }
    
    // 2. –ù–∞—á–∏—Å–ª—è–µ–º –º–æ–Ω–µ—Ç—ã –ø—Ä–æ–¥–∞–≤—Ü—É (–º–∏–Ω—É—Å 5% –∫–æ–º–∏—Å—Å–∏—è)
    const platformFee = Math.floor(price * 0.05);
    const sellerAmount = price - platformFee;
    
    if (payment_method === 'coins') {
      const { data: seller } = await supabase
        .from('_pidr_users')
        .select('coins')
        .eq('telegram_id', listing.seller_user_id)
        .single();
      
      if (seller) {
        await supabase
          .from('_pidr_users')
          .update({ coins: seller.coins + sellerAmount })
          .eq('telegram_id', listing.seller_user_id);
      }
    }
    
    // 3. –ü–µ—Ä–µ–Ω–æ—Å–∏–º NFT –∫ –ø–æ–∫—É–ø–∞—Ç–µ–ª—é
    const { error: transferError } = await supabase
      .from('_pidr_nft_cards')
      .update({ user_id: buyerId })
      .eq('id', listing.nft_card_id);
    
    if (transferError) {
      console.error('‚ùå [Marketplace Buy] –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–Ω–æ—Å–∞ NFT:', transferError);
      // –û—Ç–∫–∞—Ç—ã–≤–∞–µ–º –º–æ–Ω–µ—Ç—ã
      if (payment_method === 'coins') {
        await supabase
          .from('_pidr_users')
          .update({ coins: buyer.coins })
          .eq('telegram_id', buyerId);
      }
      return NextResponse.json(
        { success: false, error: '–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–Ω–æ—Å–∞ NFT' },
        { status: 500 }
      );
    }
    
    // 4. –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ª–æ—Ç–∞
    const { error: updateError } = await supabase
      .from('_pidr_nft_marketplace')
      .update({
        status: 'sold',
        buyer_user_id: buyerId,
        sold_at: new Date().toISOString()
      })
      .eq('id', listing_id);
    
    if (updateError) {
      console.error('‚ùå [Marketplace Buy] –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ª–æ—Ç–∞:', updateError);
    }
    
    // 5. –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    await supabase
      .from('_pidr_marketplace_transactions')
      .insert({
        marketplace_listing_id: listing_id,
        seller_user_id: listing.seller_user_id,
        buyer_user_id: buyerId,
        nft_card_id: listing.nft_card_id,
        transaction_type: payment_method,
        amount_coins: payment_method === 'coins' ? price : null,
        amount_crypto: payment_method === 'crypto' ? price : null,
        crypto_currency: payment_method === 'crypto' ? listing.crypto_currency : null,
        platform_fee_coins: payment_method === 'coins' ? platformFee : null,
        platform_fee_crypto: payment_method === 'crypto' ? (price * 0.05) : null,
        status: 'completed',
        completed_at: new Date().toISOString()
      });
    
    console.log('‚úÖ [Marketplace Buy] –ü–æ–∫—É–ø–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!');
    
    return NextResponse.json({
      success: true,
      message: 'NFT —É—Å–ø–µ—à–Ω–æ –∫—É–ø–ª–µ–Ω–∞!',
      nft_card: listing.nft_card,
      paid: price,
      platform_fee: platformFee
    });
    
  } catch (error: any) {
    console.error('‚ùå [Marketplace Buy] –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞:', error);
    return NextResponse.json(
      { success: false, error: error.message || 'Internal server error' },
      { status: 500 }
    );
  }
}

